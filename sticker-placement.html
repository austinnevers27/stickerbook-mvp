<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Stickerbook â€“ Arrange Your Stickers</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="css/stickerbook.css">
  <style>
    /* Page-specific: full gesture control */
    html, body {
      touch-action: none;
    }

    /* Canvas area gets the background color */
    .canvas-area {
      flex: 1;
      display: flex;
      flex-direction: column;
      border-radius: var(--radius-lg);
      padding: 12px 10px 10px;
      position: relative;
      overflow: hidden;
      background: #ffffff; /* overridden via JS */
    }

    /* Frosted header chip */
    .header-card {
      margin-bottom: 4px;
      padding: 5px 12px;
      border-radius: var(--radius-pill);
      background: rgba(255, 255, 255, 0.9);
      border: 1px solid rgba(255, 255, 255, 0.7);
      backdrop-filter: blur(10px);
      box-shadow: 0 6px 16px rgba(15, 23, 42, 0.28);
      text-align: center;
      align-self: center;
      flex-shrink: 0;
      transition: opacity 0.25s ease, transform 0.25s ease;
    }

    .header-card.header-hidden {
      opacity: 0;
      transform: translateY(-6px);
      pointer-events: none;
    }

    .header-title {
      font-family: var(--font-display);
      font-size: 11px;
      font-weight: 600;
      letter-spacing: 0.16em;
      text-transform: uppercase;
      color: var(--color-text-primary);
      margin: 0;
    }

    /* Play area */
    .play-area {
      flex: 1;
      min-height: 0;
      margin: 4px 0 10px;
      position: relative;
    }

    #stickerCanvas {
      position: relative;
      width: 100%;
      height: 100%;
      touch-action: none;
    }

    /* Draggable stickers (different from splash stickers) */
    .placement-sticker {
      position: absolute;
      touch-action: none;
      user-select: none;
      transform-origin: center center;
      cursor: grab;
      border-radius: var(--radius-md);
    }

    .placement-sticker img {
      width: 100%;
      height: 100%;
      object-fit: contain;
      pointer-events: none;
      user-select: none;
      display: block;
    }

    .placement-sticker.active {
      box-shadow: 0 0 0 2px rgba(14, 165, 233, 0.7), 0 8px 18px rgba(15, 23, 42, 0.45);
    }

    /* Footer buttons */
    .footer-row {
      display: flex;
      align-items: center;
      gap: 10px;
      flex-shrink: 0;
    }

    .footer-row .btn-outline {
      flex: 0 0 auto;
    }

    .footer-row .btn-outline.hidden-remove {
      opacity: 0;
      pointer-events: none;
      transform: translateY(4px);
      box-shadow: none;
    }

    .footer-row .btn-primary {
      flex: 1;
      width: auto;
      padding: 9px 20px;
    }

    /* Background picker overlay */
    .bg-picker-overlay {
      position: absolute;
      inset: 0;
      background: rgba(15, 23, 42, 0.6);
      backdrop-filter: blur(4px);
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s ease;
      z-index: 100;
    }

    .bg-picker-overlay.visible {
      opacity: 1;
      pointer-events: auto;
    }

    .bg-picker-card {
      background: white;
      border-radius: var(--radius-lg);
      padding: 16px;
      box-shadow: 0 20px 40px rgba(15, 23, 42, 0.3);
      max-width: 280px;
      width: 90%;
    }

    .bg-picker-title {
      font-family: var(--font-display);
      font-size: 11px;
      font-weight: 600;
      letter-spacing: 0.12em;
      text-transform: uppercase;
      color: var(--color-text-primary);
      margin-bottom: 12px;
      text-align: center;
    }

    .bg-picker-grid {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 8px;
    }

    .bg-picker-swatch {
      aspect-ratio: 1;
      border-radius: 8px;
      cursor: pointer;
      border: 2px solid transparent;
      transition: transform 0.12s ease, border-color 0.12s ease;
      box-shadow: 0 2px 6px rgba(0,0,0,0.15);
    }

    .bg-picker-swatch:hover {
      transform: scale(1.08);
    }

    .bg-picker-swatch.selected {
      border-color: var(--color-cyan);
    }

    .bg-picker-close {
      margin-top: 12px;
      width: 100%;
      padding: 8px;
      border: none;
      border-radius: var(--radius-pill);
      background: var(--color-field-bg);
      color: var(--color-text-muted);
      font-size: 11px;
      cursor: pointer;
    }

    /* Paint button */
    .btn-icon {
      width: 36px;
      height: 36px;
      border-radius: 50%;
      border: 1px solid rgba(248, 250, 252, 0.85);
      background: rgba(15, 23, 42, 0.14);
      color: #f9fafb;
      font-size: 16px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: transform 0.12s ease, background 0.15s ease;
    }

    .btn-icon:hover {
      background: rgba(15, 23, 42, 0.25);
    }

    .btn-icon:active {
      transform: scale(0.95);
    }

    /* Save toast */
    .save-toast {
      position: absolute;
      bottom: 14px;
      left: 50%;
      transform: translateX(-50%);
      padding: 6px 12px;
      border-radius: var(--radius-pill);
      background: rgba(15, 23, 42, 0.9);
      color: #f9fafb;
      font-size: 10px;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.18s ease;
      z-index: 3;
    }

    .save-toast.visible {
      opacity: 1;
    }

    @media (max-width: 480px) {
      .canvas-area {
        padding: 10px 8px 10px;
      }

      .header-title {
        font-size: 10px;
      }
    }
  </style>
</head>
<body>
  <div class="app-shell">
    <div class="phone-frame">
      <div class="phone-inner">
        <div class="shell-inner">
          <!-- Logo -->
          <div class="top-row top-row--centered">
            <div class="logo-group" style="align-items: center;">
              <div class="logo-mark">STICKERBOOK</div>
              <div class="logo-accent"></div>
            </div>
          </div>

          <!-- Canvas area (gets background color) -->
          <div class="canvas-area" id="canvas-area">
            <!-- Tiny header chip -->
            <div class="header-card" id="header-card">
              <h1 class="header-title">Arrange your stickers</h1>
            </div>

            <!-- Central play area -->
            <div class="play-area" id="play-area">
              <div id="stickerCanvas"></div>
            </div>

            <!-- Footer actions -->
            <div class="footer-row">
              <button id="bg-picker-btn" class="btn-icon" type="button" title="Change background">
                ðŸŽ¨
              </button>
              <button id="remove-button" class="btn-outline hidden-remove" type="button" disabled>
                Remove sticker
              </button>
              <button id="continue-button" class="btn btn-primary" type="button">
                Continue
              </button>
            </div>

            <!-- Background picker overlay -->
            <div class="bg-picker-overlay" id="bg-picker-overlay">
              <div class="bg-picker-card">
                <div class="bg-picker-title">Change Background</div>
                <div class="bg-picker-grid" id="bg-picker-grid">
                  <!-- Swatches injected by JS -->
                </div>
                <button class="bg-picker-close" id="bg-picker-close">Cancel</button>
              </div>
            </div>

            <div id="save-toast" class="save-toast">Page saved</div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    const GRID_COLS = 4;
    const GRID_ROWS = 5;
    const SAFE_MARGIN = 8;

    const MIN_SCALE = 0.5;
    const MAX_SCALE = 5;

    const BACKGROUND_COLORS = [
      "#ffffff", "#e5e7eb", "#fef3c7",
      "#020617", "#1d4ed8", "#92400e",
      "#ef4444", "#fb923c", "#facc15",
      "#22c55e", "#0ea5e9", "#a855f7"
    ];

    const canvasArea = document.getElementById("canvas-area");
    const playArea = document.getElementById("play-area");
    const canvas = document.getElementById("stickerCanvas");
    const removeButton = document.getElementById("remove-button");
    const continueButton = document.getElementById("continue-button");
    const saveToast = document.getElementById("save-toast");
    const headerCard = document.getElementById("header-card");

    const bgPickerBtn = document.getElementById("bg-picker-btn");
    const bgPickerOverlay = document.getElementById("bg-picker-overlay");
    const bgPickerGrid = document.getElementById("bg-picker-grid");
    const bgPickerClose = document.getElementById("bg-picker-close");

    const isTouchDevice =
      "ontouchstart" in window || navigator.maxTouchPoints > 0;

    let pageData = null;
    let stickersData = [];
    let currentZ = 10;
    let activeSticker = null;
    let canvasBounds = { width: 0, height: 0 };
    let headerHidden = false;

    // ============ BACKGROUND PICKER ============
    function initBackgroundPicker() {
      bgPickerGrid.innerHTML = "";
      
      const currentBg = pageData?.background || "#ffffff";
      
      BACKGROUND_COLORS.forEach(color => {
        const swatch = document.createElement("div");
        swatch.className = "bg-picker-swatch";
        if (color === currentBg) {
          swatch.classList.add("selected");
        }
        swatch.style.backgroundColor = color;
        swatch.dataset.color = color;
        
        swatch.addEventListener("click", () => {
          selectBackground(color);
        });
        
        bgPickerGrid.appendChild(swatch);
      });
    }

    function selectBackground(color) {
      // Update UI
      canvasArea.style.background = color;
      
      // Update data
      if (pageData) {
        pageData.background = color;
      }
      
      // Update localStorage
      localStorage.setItem("stickerbook_page_1_background", color);
      localStorage.setItem("current_page_background", color);
      
      // Save full layout
      saveLayoutToStorage();
      
      // Close picker
      closeBgPicker();
      
      // Show feedback
      showToast();
    }

    function openBgPicker() {
      initBackgroundPicker();
      bgPickerOverlay.classList.add("visible");
    }

    function closeBgPicker() {
      bgPickerOverlay.classList.remove("visible");
    }

    bgPickerBtn.addEventListener("click", (e) => {
      e.stopPropagation();
      openBgPicker();
    });

    bgPickerClose.addEventListener("click", (e) => {
      e.stopPropagation();
      closeBgPicker();
    });

    bgPickerOverlay.addEventListener("click", (e) => {
      if (e.target === bgPickerOverlay) {
        closeBgPicker();
      }
    });

    // ============ EXISTING FUNCTIONS ============
    function hideHeaderCard() {
      if (headerHidden || !headerCard) return;
      headerHidden = true;
      headerCard.classList.add("header-hidden");
    }

    function showToast() {
      saveToast.classList.add("visible");
      setTimeout(() => {
        saveToast.classList.remove("visible");
      }, 1500);
    }

    // Load page data and normalize src/image
    function loadPageFromStorage() {
      const rawPage = localStorage.getItem("stickerbook_page_1");
      if (rawPage) {
        try {
          pageData = JSON.parse(rawPage);
        } catch {
          pageData = null;
        }
      }

      if (!pageData || !pageData.stickers || !Array.isArray(pageData.stickers)) {
        const bg =
          localStorage.getItem("stickerbook_page_1_background") ||
          localStorage.getItem("current_page_background") ||
          "#ffffff";

        let stickerIds = [];
        try {
          const rawSel = localStorage.getItem("stickerbookSelectedStickers");
          if (rawSel) {
            const arr = JSON.parse(rawSel);
            if (Array.isArray(arr)) stickerIds = arr;
          }
        } catch {
          stickerIds = [];
        }

        pageData = {
          background: bg,
          stickers: stickerIds.map((id) => ({ id, src: null }))
        };

        try {
          const allPagesRaw = localStorage.getItem("stickerbook_pages");
          if (allPagesRaw) {
            const allPages = JSON.parse(allPagesRaw);
            if (allPages && allPages.page_1 && Array.isArray(allPages.page_1.stickers)) {
              const map = {};
              allPages.page_1.stickers.forEach((s) => {
                map[s.id] = s.src || s.image;
              });
              pageData.stickers.forEach((s) => {
                if (!s.src && map[s.id]) {
                  s.src = map[s.id];
                }
              });
            }
          }
        } catch {
          // ignore
        }
      } else {
        try {
          const allPagesRaw = localStorage.getItem("stickerbook_pages");
          if (allPagesRaw) {
            const allPages = JSON.parse(allPagesRaw);
            if (allPages && allPages.page_1 && Array.isArray(allPages.page_1.stickers)) {
              const map = {};
              allPages.page_1.stickers.forEach((s) => {
                map[s.id] = s.src || s.image;
              });
              pageData.stickers.forEach((s) => {
                if (!s.src && map[s.id]) {
                  s.src = map[s.id];
                }
              });
            }
          }
        } catch {
          // ignore
        }
      }

      if (pageData && Array.isArray(pageData.stickers)) {
        pageData.stickers.forEach((s) => {
          if (!s.src && s.image) {
            s.src = s.image;
          }
        });
      }

      pageData.stickers = (pageData.stickers || []).filter((s) => !!s.src);
    }

    function updateBackground() {
      const bg = pageData && pageData.background ? pageData.background : "#ffffff";
      canvasArea.style.background = bg;
    }

    function recalcCanvasBounds() {
      const rect = playArea.getBoundingClientRect();
      canvasBounds.width = rect.width;
      canvasBounds.height = rect.height;
    }

    // initial grid: set centers, not final box size
    function layoutStickersOnGrid() {
      if (!pageData || !pageData.stickers) return;

      recalcCanvasBounds();

      const innerWidth = canvasBounds.width - SAFE_MARGIN * 2;
      const innerHeight = canvasBounds.height - SAFE_MARGIN * 2;
      const cellWidth = innerWidth / GRID_COLS;
      const cellHeight = innerHeight / GRID_ROWS;

      const maxCells = GRID_COLS * GRID_ROWS;
      const count = Math.min(pageData.stickers.length, maxCells);

      for (let index = 0; index < count; index++) {
        const sticker = pageData.stickers[index];

        if (
          typeof sticker.x === "number" &&
          typeof sticker.y === "number" &&
          typeof sticker.scale === "number" &&
          typeof sticker.rotation === "number"
        ) {
          continue;
        }

        const row = Math.floor(index / GRID_COLS);
        const col = index % GRID_COLS;

        const cellCenterX = SAFE_MARGIN + col * cellWidth + cellWidth / 2;
        const cellCenterY = SAFE_MARGIN + row * cellHeight + cellHeight / 2;

        const stickerSize = Math.min(cellWidth, cellHeight) * 0.95;

        sticker.scale = 1;
        sticker.rotation = 0;
        sticker.size = stickerSize;

        const halfSize = stickerSize / 2;
        sticker.x = cellCenterX - halfSize;
        sticker.y = cellCenterY - halfSize;
      }

      for (let i = maxCells; i < pageData.stickers.length; i++) {
        const sticker = pageData.stickers[i];

        if (typeof sticker.x === "number" && typeof sticker.y === "number") {
          continue;
        }

        const stickerSize = Math.min(cellWidth, cellHeight) * 0.95;
        sticker.scale = 1;
        sticker.rotation = 0;
        sticker.size = stickerSize;
        const halfSize = stickerSize / 2;
        sticker.x = canvasBounds.width / 2 - halfSize;
        sticker.y = canvasBounds.height - SAFE_MARGIN - stickerSize;
      }

      stickersData = pageData.stickers;
    }

    function getStickerBaseDimensions(stickerObj) {
      const defaultSize = stickerObj.size || 80;
      const baseWidth = stickerObj.baseWidth || stickerObj.width || defaultSize;
      const baseHeight = stickerObj.baseHeight || stickerObj.height || defaultSize;
      return { baseWidth, baseHeight };
    }

    function clampStickerPosition(stickerObj) {
      const { baseWidth, baseHeight } = getStickerBaseDimensions(stickerObj);
      const scale = stickerObj.scale || 1;

      const scaledWidth = baseWidth * scale;
      const scaledHeight = baseHeight * scale;

      const extraX = (scaledWidth - baseWidth) / 2;
      const extraY = (scaledHeight - baseHeight) / 2;

      const minX = SAFE_MARGIN;
      const maxX = canvasBounds.width - baseWidth - SAFE_MARGIN;

      const minY = SAFE_MARGIN + extraY;
      const maxY = canvasBounds.height - SAFE_MARGIN - baseHeight - extraY;

      if (stickerObj.x < minX) stickerObj.x = minX;
      if (stickerObj.x > maxX) stickerObj.x = maxX;

      if (minY > maxY) {
        const mid = (canvasBounds.height - baseHeight) / 2;
        stickerObj.y = mid;
      } else {
        if (stickerObj.y < minY) stickerObj.y = minY;
        if (stickerObj.y > maxY) stickerObj.y = maxY;
      }
    }

    function setActiveSticker(el) {
      if (activeSticker === el) return;

      hideHeaderCard();

      if (activeSticker) {
        activeSticker.classList.remove("active");
      }
      activeSticker = el;

      if (activeSticker) {
        activeSticker.classList.add("active");
        removeButton.disabled = false;
        removeButton.classList.remove("hidden-remove");
      } else {
        removeButton.disabled = true;
        removeButton.classList.add("hidden-remove");
      }
    }

    function saveLayoutToStorage() {
      const els = Array.from(canvas.querySelectorAll(".placement-sticker"));
      const stickers = els.map((el) => ({
        id: el.dataset.id,
        src: el.dataset.src,
        x: parseFloat(el.dataset.x) || 0,
        y: parseFloat(el.dataset.y) || 0,
        scale: parseFloat(el.dataset.scale) || 1,
        rotation: parseFloat(el.dataset.rotation) || 0,
        zIndex: parseInt(el.style.zIndex || "1", 10),
        width: parseFloat(el.dataset.width) || undefined,
        height: parseFloat(el.dataset.height) || undefined
      }));

      const bg =
        (pageData && pageData.background) ||
        canvasArea.style.background ||
        "#ffffff";

      const page1 = {
        background: bg,
        stickers
      };

      localStorage.setItem("stickerbook_page_1", JSON.stringify(page1));

      try {
        const existingRaw = localStorage.getItem("stickerbook_pages");
        const existing = existingRaw ? JSON.parse(existingRaw) : {};
        existing.page_1 = page1;
        localStorage.setItem("stickerbook_pages", JSON.stringify(existing));
      } catch {
        localStorage.setItem("stickerbook_pages", JSON.stringify({ page_1: page1 }));
      }
    }

    function handleRemoveActiveSticker() {
      if (!activeSticker) return;

      const id = activeSticker.dataset.id;
      stickersData = stickersData.filter((s) => s.id !== id);

      activeSticker.remove();
      setActiveSticker(null);
      saveLayoutToStorage();
    }

    function createStickerElement(stickerObj) {
      const el = document.createElement("div");
      el.className = "placement-sticker";

      const baseSize = stickerObj.size || 80;

      let baseWidth = stickerObj.width || baseSize;
      let baseHeight = stickerObj.height || baseSize;

      stickerObj.baseWidth = baseWidth;
      stickerObj.baseHeight = baseHeight;

      clampStickerPosition(stickerObj);

      el.style.width = baseWidth + "px";
      el.style.height = baseHeight + "px";
      el.style.left = stickerObj.x + "px";
      el.style.top = stickerObj.y + "px";

      const scale = stickerObj.scale || 1;
      const rotation = stickerObj.rotation || 0;

      el.style.transform = `scale(${scale}) rotate(${rotation}deg)`;
      el.style.zIndex = (stickerObj.zIndex && Number.isFinite(stickerObj.zIndex))
        ? stickerObj.zIndex
        : ++currentZ;

      el.dataset.id = stickerObj.id;
      el.dataset.src = stickerObj.src;
      el.dataset.x = stickerObj.x;
      el.dataset.y = stickerObj.y;
      el.dataset.scale = scale;
      el.dataset.rotation = rotation;
      el.dataset.width = baseWidth;
      el.dataset.height = baseHeight;

      const img = document.createElement("img");
      img.src = stickerObj.src;
      img.alt = "";
      el.appendChild(img);

      // adjust to real aspect once image loads
      img.addEventListener("load", () => {
        const iw = img.naturalWidth;
        const ih = img.naturalHeight;
        if (!iw || !ih) return;

        const maxDim = stickerObj.size || baseSize;
        let w, h;
        const aspect = ih / iw;

        if (iw >= ih) {
          w = maxDim;
          h = maxDim * aspect;
        } else {
          h = maxDim;
          w = maxDim / aspect;
        }

        stickerObj.baseWidth = w;
        stickerObj.baseHeight = h;
        stickerObj.width = w;
        stickerObj.height = h;

        const scaleNow = stickerObj.scale || 1;
        const rotationNow = stickerObj.rotation || 0;

        const centerX = stickerObj.x + baseWidth / 2;
        const centerY = stickerObj.y + baseHeight / 2;
        stickerObj.x = centerX - w / 2;
        stickerObj.y = centerY - h / 2;

        clampStickerPosition(stickerObj);

        el.style.width = w + "px";
        el.style.height = h + "px";
        el.style.left = stickerObj.x + "px";
        el.style.top = stickerObj.y + "px";
        el.style.transform = `scale(${scaleNow}) rotate(${rotationNow}deg)`;

        el.dataset.x = stickerObj.x;
        el.dataset.y = stickerObj.y;
        el.dataset.width = w;
        el.dataset.height = h;
      });

      el.addEventListener("click", (event) => {
        event.stopPropagation();
        setActiveSticker(el);
        el.style.zIndex = ++currentZ;
      });

      setupDesktopDrag(el);
      setupTouchGestures(el);

      return el;
    }

    function setupDesktopDrag(el) {
      if (isTouchDevice) return;

      el.addEventListener("mousedown", (e) => {
        e.preventDefault();
        e.stopPropagation();

        setActiveSticker(el);
        el.style.zIndex = ++currentZ;

        const id = el.dataset.id;
        const st = stickersData.find((s) => s.id === id);
        if (!st) return;

        const startX = st.x;
        const startY = st.y;
        const startMouseX = e.clientX;
        const startMouseY = e.clientY;

        function onMove(ev) {
          const dx = ev.clientX - startMouseX;
          const dy = ev.clientY - startMouseY;

          st.x = startX + dx;
          st.y = startY + dy;

          clampStickerPosition(st);

          el.dataset.x = st.x;
          el.dataset.y = st.y;
          el.style.left = st.x + "px";
          el.style.top = st.y + "px";
        }

        function onUp() {
          window.removeEventListener("mousemove", onMove);
          window.removeEventListener("mouseup", onUp);
          saveLayoutToStorage();
        }

        window.addEventListener("mousemove", onMove);
        window.addEventListener("mouseup", onUp);
      });
    }

    function setupTouchGestures(el) {
      if (!isTouchDevice) return;

      let touchMode = null;
      let startX = 0;
      let startY = 0;
      let startTouchX = 0;
      let startTouchY = 0;

      let initialDistance = 0;
      let initialAngle = 0;
      let startScale = 1;
      let startRotation = 0;

      const getStickerState = () => {
        const id = el.dataset.id;
        return stickersData.find((s) => s.id === id);
      };

      el.addEventListener("touchstart", (e) => {
        if (e.touches.length === 0) return;
        setActiveSticker(el);
        el.style.zIndex = ++currentZ;

        const st = getStickerState();
        if (!st) return;

        if (e.touches.length === 1) {
          touchMode = "pan";
          const t = e.touches[0];
          startX = st.x;
          startY = st.y;
          startTouchX = t.clientX;
          startTouchY = t.clientY;
        } else if (e.touches.length === 2) {
          touchMode = "transform";
          const t1 = e.touches[0];
          const t2 = e.touches[1];
          const dx = t2.clientX - t1.clientX;
          const dy = t2.clientY - t1.clientY;
          const distance = Math.hypot(dx, dy) || 1;
          const angle = Math.atan2(dy, dx);

          initialDistance = distance;
          initialAngle = angle;

          startScale = st.scale || parseFloat(el.dataset.scale) || 1;
          startRotation = st.rotation || parseFloat(el.dataset.rotation) || 0;
        }
      }, { passive: false });

      el.addEventListener("touchmove", (e) => {
        if (!touchMode) return;
        const st = getStickerState();
        if (!st) return;

        e.preventDefault();

        if (touchMode === "pan" && e.touches.length === 1) {
          const t = e.touches[0];
          const dx = t.clientX - startTouchX;
          const dy = t.clientY - startTouchY;

          st.x = startX + dx;
          st.y = startY + dy;

          clampStickerPosition(st);

          el.dataset.x = st.x;
          el.dataset.y = st.y;
          el.style.left = st.x + "px";
          el.style.top = st.y + "px";
        } else if (touchMode === "transform" && e.touches.length >= 2) {
          const t1 = e.touches[0];
          const t2 = e.touches[1];
          const dx = t2.clientX - t1.clientX;
          const dy = t2.clientY - t1.clientY;

          const distance = Math.hypot(dx, dy);
          const angle = Math.atan2(dy, dx);

          const scaleFactor = distance / (initialDistance || distance);
          let newScale = startScale * scaleFactor;

          if (newScale < MIN_SCALE) newScale = MIN_SCALE;
          if (newScale > MAX_SCALE) newScale = MAX_SCALE;

          const rotationDelta = angle - initialAngle;
          const newRotation = startRotation + (rotationDelta * 180 / Math.PI);

          st.scale = newScale;
          st.rotation = newRotation;

          clampStickerPosition(st);

          el.dataset.x = st.x;
          el.dataset.y = st.y;
          el.dataset.scale = newScale;
          el.dataset.rotation = newRotation;
          el.style.left = st.x + "px";
          el.style.top = st.y + "px";
          el.style.transform = `scale(${newScale}) rotate(${newRotation}deg)`;
        }
      }, { passive: false });

      const handleTouchEndOrCancel = (e) => {
        const st = getStickerState();
        if (!st) {
          touchMode = null;
          return;
        }

        if (e.touches.length === 0) {
          touchMode = null;
          saveLayoutToStorage();
        } else if (touchMode === "transform" && e.touches.length === 1) {
          const t = e.touches[0];
          startX = st.x;
          startY = st.y;
          startTouchX = t.clientX;
          startTouchY = t.clientY;
          touchMode = "pan";
        }
      };

      el.addEventListener("touchend", handleTouchEndOrCancel, { passive: false });
      el.addEventListener("touchcancel", handleTouchEndOrCancel, { passive: false });
    }

    function renderStickers() {
      canvas.innerHTML = "";
      stickersData.forEach((sticker) => {
        const el = createStickerElement(sticker);
        canvas.appendChild(el);
      });
      setActiveSticker(null);
    }

    function init() {
      loadPageFromStorage();

      if (!pageData || !Array.isArray(pageData.stickers) || pageData.stickers.length === 0) {
        canvas.innerHTML = "<p style='padding:12px;font-size:12px;color:#6b7280;text-align:center;'>No stickers found for this page. Go back and choose some first.</p>";
        removeButton.disabled = true;
        removeButton.classList.add("hidden-remove");
        updateBackground();
        return;
      }

      updateBackground();
      recalcCanvasBounds();
      layoutStickersOnGrid();
      renderStickers();

      setTimeout(hideHeaderCard, 5000);

      removeButton.addEventListener("click", (event) => {
        event.stopPropagation();
        handleRemoveActiveSticker();
      });

      continueButton.addEventListener("click", () => {
        saveLayoutToStorage();
        showToast();
      });

      playArea.addEventListener("click", (event) => {
        if (event.target === playArea || event.target === canvas) {
          setActiveSticker(null);
        }
      });

      window.addEventListener("resize", () => {
        recalcCanvasBounds();
      });
    }

    document.addEventListener("DOMContentLoaded", init);
  </script>
</body>
</html>