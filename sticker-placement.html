<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Stickerbook â€“ Arrange Your Stickers</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <!-- Fonts -->
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@600;700&family=Inter:wght@400;500;600&display=swap" rel="stylesheet">

  <!-- Hammer.js for touch gestures -->
  <script src="https://hammerjs.github.io/dist/hammer.min.js"></script>

  <style>
    :root {
      --bg-pink: #ffeef7;
      --bg-blue: #e7f9ff;

      --shell-bg: #ffffff;
      --shell-border: rgba(148, 163, 184, 0.12);
      --shell-shadow-main: 0 18px 40px rgba(15, 23, 42, 0.20);

      --text-main: #111827;
      --text-muted: #6b7280;
      --text-subtle: #9ca3af;

      --button-gradient: linear-gradient(135deg, #ff4f96, #ff7a4e, #22d3ee);
      --button-text: #ffffff;

      --frosted-bg: rgba(255, 255, 255, 0.9);
      --frosted-border: rgba(255, 255, 255, 0.7);
      --frosted-shadow: 0 6px 16px rgba(15, 23, 42, 0.28);
    }

    * {
      box-sizing: border-box;
    }

    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
    }

    body {
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      background:
        radial-gradient(circle at top left, var(--bg-pink) 0, #ffffff 45%),
        radial-gradient(circle at bottom right, var(--bg-blue) 0, #ffffff 45%);
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Inter", "Segoe UI", sans-serif;
      color: var(--text-main);
      padding: 16px;
    }

    .app-shell {
      width: 100%;
      max-width: 420px;
      display: flex;
      justify-content: center;
    }

    .phone-frame {
      width: 100%;
      max-width: 380px;
      background: #ffffff;
      border-radius: 32px;
      padding: 24px 18px 24px;
      box-shadow:
        0 18px 40px rgba(15, 23, 42, 0.20),
        0 0 0 1px rgba(148, 163, 184, 0.10);
      display: flex;
      flex-direction: column;
      align-items: center;

      height: 700px;
      max-height: calc(100vh - 80px);
      overflow: hidden;
    }

    .phone-notch {
      width: 80px;
      height: 6px;
      border-radius: 999px;
      background: #e5e7eb;
      margin-bottom: 12px;
      flex-shrink: 0;
    }

    .phone-inner {
      width: 100%;
      border-radius: 26px;
      border: 1px solid rgba(148, 163, 184, 0.35);
      background: #0ea5e9; /* overridden via JS with chosen background */
      padding: 12px 10px 10px;
      display: flex;
      flex-direction: column;
      align-items: center;
      flex: 1;
      overflow: hidden;
      position: relative;
    }

    .shell-inner {
      width: 100%;
      max-width: 320px;
      margin: 0 auto;
      display: flex;
      flex-direction: column;
      align-items: stretch;
      height: 100%;
      position: relative;
      z-index: 1;
    }

    /* Logo */
    .top-row {
      display: flex;
      align-items: center;
      justify-content: center;
      margin-bottom: 4px;
      flex-shrink: 0;
    }

    .logo-group {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 4px;
    }

    .logo-mark {
      font-family: "Poppins", system-ui, sans-serif;
      font-size: 12px;
      font-weight: 700;
      letter-spacing: 0.20em;
      text-transform: uppercase;
      color: var(--text-main);
    }

    .logo-accent {
      width: 80px;
      height: 3px;
      border-radius: 999px;
      background: linear-gradient(90deg, #ff4f96, #ff7a4e, #22d3ee);
    }

    /* Very small header chip */
    .header-card {
      margin-bottom: 4px;
      padding: 5px 12px;
      border-radius: 999px;
      background: var(--frosted-bg);
      border: 1px solid var(--frosted-border);
      backdrop-filter: blur(10px);
      box-shadow: var(--frosted-shadow);
      text-align: center;
      align-self: center;
      flex-shrink: 0;
    }

    .header-title {
      font-family: "Poppins", system-ui, sans-serif;
      font-size: 11px;
      font-weight: 600;
      letter-spacing: 0.16em;
      text-transform: uppercase;
      color: var(--text-main);
      margin: 0;
    }

    /* Play area */
    .play-area {
      flex: 1;
      min-height: 0;
      margin: 4px 0 10px;
      position: relative;
    }

    #stickerCanvas {
      position: relative;
      width: 100%;
      height: 100%;
      touch-action: none;
    }

    .sticker {
      position: absolute;
      touch-action: none;
      user-select: none;
      transform-origin: center center;
      cursor: grab;
      border-radius: 18px;
    }

    .sticker img {
      width: 100%;
      height: 100%;
      object-fit: contain;
      pointer-events: none;
      user-select: none;
      display: block;
    }

    .sticker.active {
      box-shadow:
        0 0 0 2px rgba(14, 165, 233, 0.7),
        0 8px 18px rgba(15, 23, 42, 0.45);
    }

    /* Footer buttons */
    .footer-row {
      display: flex;
      align-items: center;
      gap: 10px;
      flex-shrink: 0;
    }

    .btn-outline {
      border-radius: 999px;
      border: 1px solid rgba(248, 250, 252, 0.85);
      padding: 8px 14px;
      font-size: 11px;
      font-weight: 600;
      cursor: pointer;
      background: rgba(15, 23, 42, 0.14);
      color: #f9fafb;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      white-space: nowrap;
      transition:
        transform 0.12s ease,
        box-shadow 0.18s ease,
        opacity 0.18s ease,
        background 0.18s ease;
      flex: 0 0 auto;
    }

    .btn-outline.hidden-remove {
      opacity: 0;
      pointer-events: none;
      transform: translateY(4px);
      box-shadow: none;
    }

    .btn-outline:not(.hidden-remove):active {
      transform: translateY(1px) scale(0.99);
      box-shadow: 0 4px 10px rgba(15, 23, 42, 0.55);
    }

    .btn-primary {
      border-radius: 999px;
      border: none;
      padding: 9px 20px;
      font-size: 11px;
      font-weight: 700;
      cursor: pointer;
      background: var(--button-gradient);
      color: var(--button-text);
      box-shadow:
        0 12px 22px rgba(236, 72, 153, 0.35),
        0 0 0 1px rgba(248, 250, 252, 0.5);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      letter-spacing: 0.16em;
      text-transform: uppercase;
      white-space: nowrap;
      transition:
        background 0.18s ease,
        transform 0.15s ease,
        box-shadow 0.18s ease,
        opacity 0.18s ease;
      flex: 1;
    }

    .btn-primary:not(:disabled):active {
      transform: translateY(1px) scale(0.99);
      box-shadow:
        0 6px 12px rgba(236, 72, 153, 0.30);
    }

    .btn-primary:disabled {
      opacity: 0.35;
      cursor: not-allowed;
      box-shadow:
        0 0 0 1px rgba(209, 213, 219, 0.8);
      background: linear-gradient(135deg, #f9fafb, #e5e7eb);
      color: #9ca3af;
    }

    /* Save toast */
    .save-toast {
      position: absolute;
      bottom: 14px;
      left: 50%;
      transform: translateX(-50%);
      padding: 6px 12px;
      border-radius: 999px;
      background: rgba(15, 23, 42, 0.9);
      color: #f9fafb;
      font-size: 10px;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.18s ease;
      z-index: 3;
    }

    .save-toast.visible {
      opacity: 1;
    }

    @media (max-width: 480px) {
      .phone-frame {
        height: 640px;
        max-height: calc(100vh - 48px);
        padding: 20px 14px 20px;
      }

      .phone-inner {
        padding: 10px 8px 10px;
      }

      .header-title {
        font-size: 10px;
      }

      .btn-primary {
        font-size: 10px;
      }
    }
  </style>
</head>
<body>
  <div class="app-shell">
    <div class="phone-frame">
      <div class="phone-notch"></div>

      <div class="phone-inner" id="phone-inner">
        <div class="shell-inner">
          <!-- Logo -->
          <div class="top-row">
            <div class="logo-group">
              <div class="logo-mark">STICKERBOOK</div>
              <div class="logo-accent"></div>
            </div>
          </div>

          <!-- Tiny header chip (for later, we can replace with tutorial overlay) -->
          <div class="header-card">
            <h1 class="header-title">Arrange your stickers</h1>
          </div>

          <!-- Central play area -->
          <div class="play-area" id="play-area">
            <div id="stickerCanvas"></div>
          </div>

          <!-- Footer actions -->
          <div class="footer-row">
            <button id="remove-button" class="btn-outline hidden-remove" type="button" disabled>
              Remove sticker
            </button>
            <button id="continue-button" class="btn-primary" type="button">
              Continue
            </button>
          </div>
        </div>

        <div id="save-toast" class="save-toast">Page saved</div>
      </div>
    </div>
  </div>

  <script>
    const GRID_COLS = 4;
    const GRID_ROWS = 5; // up to 20 stickers
    const SAFE_MARGIN = 8; // padding inside play area bounds

    const phoneInner = document.getElementById("phone-inner");
    const playArea = document.getElementById("play-area");
    const canvas = document.getElementById("stickerCanvas");
    const removeButton = document.getElementById("remove-button");
    const continueButton = document.getElementById("continue-button");
    const saveToast = document.getElementById("save-toast");

    let pageData = null;
    let stickersData = [];
    let currentZ = 10;
    let activeSticker = null;
    let canvasBounds = { width: 0, height: 0 };

    function showToast() {
      saveToast.classList.add("visible");
      setTimeout(() => {
        saveToast.classList.remove("visible");
      }, 1500);
    }

    function loadPageFromStorage() {
      const rawPage = localStorage.getItem("stickerbook_page_1");
      if (rawPage) {
        try {
          pageData = JSON.parse(rawPage);
        } catch {
          pageData = null;
        }
      }

      if (!pageData || !pageData.stickers || !Array.isArray(pageData.stickers)) {
        const bg =
          localStorage.getItem("stickerbook_page_1_background") ||
          localStorage.getItem("current_page_background") ||
          "#ffffff";

        let stickerIds = [];
        try {
          const rawSel = localStorage.getItem("stickerbookSelectedStickers");
          if (rawSel) {
            const arr = JSON.parse(rawSel);
            if (Array.isArray(arr)) stickerIds = arr;
          }
        } catch {
          stickerIds = [];
        }

        pageData = {
          background: bg,
          stickers: stickerIds.map((id) => ({ id, src: null }))
        };
      }

      // Try to hydrate src from stickerbook_pages
      try {
        const allPagesRaw = localStorage.getItem("stickerbook_pages");
        if (allPagesRaw) {
          const allPages = JSON.parse(allPagesRaw);
          if (allPages && allPages.page_1 && Array.isArray(allPages.page_1.stickers)) {
            const map = {};
            allPages.page_1.stickers.forEach((s) => {
              map[s.id] = s.src || s.image;
            });
            pageData.stickers.forEach((s) => {
              if (!s.src && map[s.id]) {
                s.src = map[s.id];
              }
            });
          }
        }
      } catch {
        // ignore
      }

      pageData.stickers = pageData.stickers.filter((s) => !!s.src);
    }

    function updateBackground() {
      const bg = pageData && pageData.background ? pageData.background : "#ffffff";
      phoneInner.style.background = bg;
    }

    function recalcCanvasBounds() {
      const rect = playArea.getBoundingClientRect();
      canvasBounds.width = rect.width;
      canvasBounds.height = rect.height;
    }

    // ALWAYS lay out fresh on load in a grid so nothing overlaps
    function layoutStickersOnGrid() {
      if (!pageData || !pageData.stickers) return;

      recalcCanvasBounds();

      const innerWidth = canvasBounds.width - SAFE_MARGIN * 2;
      const innerHeight = canvasBounds.height - SAFE_MARGIN * 2;
      const cellWidth = innerWidth / GRID_COLS;
      const cellHeight = innerHeight / GRID_ROWS;

      const maxCells = GRID_COLS * GRID_ROWS;
      const count = Math.min(pageData.stickers.length, maxCells);

      for (let index = 0; index < count; index++) {
        const sticker = pageData.stickers[index];
        const row = Math.floor(index / GRID_COLS);
        const col = index % GRID_COLS;

        const cellCenterX = SAFE_MARGIN + col * cellWidth + cellWidth / 2;
        const cellCenterY = SAFE_MARGIN + row * cellHeight + cellHeight / 2;

        const stickerSize = Math.min(cellWidth, cellHeight) * 0.8;

        sticker.scale = 1;
        sticker.rotation = 0;
        sticker.size = stickerSize;

        const halfSize = stickerSize / 2;
        sticker.x = cellCenterX - halfSize;
        sticker.y = cellCenterY - halfSize;
      }

      // If there are extra stickers beyond grid capacity, stack along bottom center
      for (let i = maxCells; i < pageData.stickers.length; i++) {
        const sticker = pageData.stickers[i];
        const stickerSize = Math.min(cellWidth, cellHeight) * 0.8;
        sticker.scale = 1;
        sticker.rotation = 0;
        sticker.size = stickerSize;
        const halfSize = stickerSize / 2;
        sticker.x = canvasBounds.width / 2 - halfSize;
        sticker.y = canvasBounds.height - SAFE_MARGIN - stickerSize;
      }

      stickersData = pageData.stickers;
    }

    function clampStickerPosition(stickerObj) {
      const size = stickerObj.size || 80;
      const minX = SAFE_MARGIN;
      const minY = SAFE_MARGIN;
      const maxX = canvasBounds.width - size - SAFE_MARGIN;
      const maxY = canvasBounds.height - size - SAFE_MARGIN;

      if (stickerObj.x < minX) stickerObj.x = minX;
      if (stickerObj.y < minY) stickerObj.y = minY;
      if (stickerObj.x > maxX) stickerObj.x = maxX;
      if (stickerObj.y > maxY) stickerObj.y = maxY;
    }

    function setActiveSticker(el) {
      if (activeSticker === el) return;

      if (activeSticker) {
        activeSticker.classList.remove("active");
      }
      activeSticker = el;

      if (activeSticker) {
        activeSticker.classList.add("active");
        removeButton.disabled = false;
        removeButton.classList.remove("hidden-remove");
      } else {
        removeButton.disabled = true;
        removeButton.classList.add("hidden-remove");
      }
    }

    function createStickerElement(stickerObj) {
      const el = document.createElement("div");
      el.className = "sticker";

      const size = stickerObj.size || 80;

      clampStickerPosition(stickerObj);

      el.style.width = size + "px";
      el.style.height = size + "px";
      el.style.left = stickerObj.x + "px";
      el.style.top = stickerObj.y + "px";

      const scale = stickerObj.scale || 1;
      const rotation = stickerObj.rotation || 0;

      el.style.transform = `scale(${scale}) rotate(${rotation}deg)`;
      el.style.zIndex = (stickerObj.zIndex && Number.isFinite(stickerObj.zIndex))
        ? stickerObj.zIndex
        : ++currentZ;

      el.dataset.id = stickerObj.id;
      el.dataset.src = stickerObj.src;
      el.dataset.x = stickerObj.x;
      el.dataset.y = stickerObj.y;
      el.dataset.scale = scale;
      el.dataset.rotation = rotation;

      const img = document.createElement("img");
      img.src = stickerObj.src;
      img.alt = "";
      el.appendChild(img);

      el.addEventListener("click", (event) => {
        event.stopPropagation();
        setActiveSticker(el);
        el.style.zIndex = ++currentZ;
      });

      attachGestureHandlers(el);

      return el;
    }

    function attachGestureHandlers(el) {
      const manager = new Hammer.Manager(el);
      const pan = new Hammer.Pan({ threshold: 0 });
      const pinch = new Hammer.Pinch({ threshold: 0 });
      const rotate = new Hammer.Rotate({ threshold: 0 });

      pinch.recognizeWith(rotate);
      manager.add([pan, pinch, rotate]);

      // IMPORTANT: enable pinch & rotate (off by default)
      manager.get('pinch').set({ enable: true });
      manager.get('rotate').set({ enable: true });

      let startX = 0;
      let startY = 0;
      let startScale = 1;
      let startRotation = 0;

      manager.on("panstart", (ev) => {
        setActiveSticker(el);
        el.style.zIndex = ++currentZ;
        startX = parseFloat(el.dataset.x) || 0;
        startY = parseFloat(el.dataset.y) || 0;
      });

      manager.on("panmove", (ev) => {
        const id = el.dataset.id;
        const st = stickersData.find((s) => s.id === id);
        if (!st) return;

        st.x = startX + ev.deltaX;
        st.y = startY + ev.deltaY;

        clampStickerPosition(st);

        el.dataset.x = st.x;
        el.dataset.y = st.y;
        el.style.left = st.x + "px";
        el.style.top = st.y + "px";
      });

      manager.on("pinchstart rotatestart", () => {
        const currentScale = parseFloat(el.dataset.scale) || 1;
        const currentRotation = parseFloat(el.dataset.rotation) || 0;
        startScale = currentScale;
        startRotation = currentRotation;
      });

      manager.on("pinchmove rotatemove", (ev) => {
        const id = el.dataset.id;
        const st = stickersData.find((s) => s.id === id);
        if (!st) return;

        let newScale = startScale * (ev.scale || 1);
        let newRotation = startRotation + (ev.rotation || 0);

        if (newScale < 0.35) newScale = 0.35;
        if (newScale > 3.0) newScale = 3.0;

        st.scale = newScale;
        st.rotation = newRotation;

        el.dataset.scale = newScale;
        el.dataset.rotation = newRotation;
        el.style.transform = `scale(${newScale}) rotate(${newRotation}deg)`;
      });
    }

    function renderStickers() {
      canvas.innerHTML = "";
      stickersData.forEach((sticker) => {
        const el = createStickerElement(sticker);
        canvas.appendChild(el);
      });
      setActiveSticker(null); // start with nothing selected
    }

    function saveLayoutToStorage() {
      const els = Array.from(canvas.querySelectorAll(".sticker"));
      const stickers = els.map((el) => ({
        id: el.dataset.id,
        src: el.dataset.src,
        x: parseFloat(el.dataset.x) || 0,
        y: parseFloat(el.dataset.y) || 0,
        scale: parseFloat(el.dataset.scale) || 1,
        rotation: parseFloat(el.dataset.rotation) || 0,
        zIndex: parseInt(el.style.zIndex || "1", 10)
      }));

      const bg =
        (pageData && pageData.background) ||
        phoneInner.style.background ||
        "#ffffff";

      const page1 = {
        background: bg,
        stickers
      };

      localStorage.setItem("stickerbook_page_1", JSON.stringify(page1));

      try {
        const existingRaw = localStorage.getItem("stickerbook_pages");
        const existing = existingRaw ? JSON.parse(existingRaw) : {};
        existing.page_1 = page1;
        localStorage.setItem("stickerbook_pages", JSON.stringify(existing));
      } catch {
        localStorage.setItem("stickerbook_pages", JSON.stringify({ page_1: page1 }));
      }
    }

    function handleRemoveActiveSticker() {
      if (!activeSticker) return;

      const id = activeSticker.dataset.id;
      stickersData = stickersData.filter((s) => s.id !== id);

      activeSticker.remove();
      setActiveSticker(null);
    }

    function init() {
      loadPageFromStorage();
      updateBackground();
      recalcCanvasBounds();
      layoutStickersOnGrid();
      renderStickers();

      // Remove button
      removeButton.addEventListener("click", (event) => {
        event.stopPropagation();
        handleRemoveActiveSticker();
      });

      // Continue button
      continueButton.addEventListener("click", () => {
        saveLayoutToStorage();
        showToast();
        // MVP: stay on page
      });

      // Tap empty space to clear selection
      playArea.addEventListener("click", (event) => {
        if (event.target === playArea || event.target === canvas) {
          setActiveSticker(null);
        }
      });

      window.addEventListener("resize", () => {
        recalcCanvasBounds();
        // do NOT re-grid on resize; user layout stays
      });
    }

    document.addEventListener("DOMContentLoaded", init);
  </script>
</body>
</html>
