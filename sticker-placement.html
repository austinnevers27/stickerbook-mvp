<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Stickerbook â€“ Arrange Your Stickers</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />

  <!-- Fonts -->
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@600;700&family=Inter:wght@400;500;600&display=swap" rel="stylesheet">

  <style>
    :root {
      --bg-pink: #ffeef7;
      --bg-blue: #e7f9ff;

      --shell-bg: #ffffff;
      --shell-border: rgba(148, 163, 184, 0.12);
      --shell-shadow-main: 0 18px 40px rgba(15, 23, 42, 0.20);

      --text-main: #111827;
      --text-muted: #6b7280;
      --text-subtle: #9ca3af;

      --button-gradient: linear-gradient(135deg, #ff4f96, #ff7a4e, #22d3ee);
      --button-text: #ffffff;

      --frosted-bg: rgba(255, 255, 255, 0.9);
      --frosted-border: rgba(255, 255, 255, 0.7);
      --frosted-shadow: 0 6px 16px rgba(15, 23, 42, 0.28);
    }

    * {
      box-sizing: border-box;
    }

    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      touch-action: none; /* full control over gestures */
    }

    body {
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      background:
        radial-gradient(circle at top left, var(--bg-pink) 0, #ffffff 45%),
        radial-gradient(circle at bottom right, var(--bg-blue) 0, #ffffff 45%);
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Inter", "Segoe UI", sans-serif;
      color: var(--text-main);
      padding: 16px;
    }

    .app-shell {
      width: 100%;
      max-width: 420px;
      display: flex;
      justify-content: center;
    }

    .phone-frame {
      width: 100%;
      max-width: 380px;
      background: #ffffff;
      border-radius: 32px;
      padding: 24px 18px 24px;
      box-shadow:
        0 18px 40px rgba(15, 23, 42, 0.20),
        0 0 0 1px rgba(148, 163, 184, 0.10);
      display: flex;
      flex-direction: column;
      align-items: center;

      height: 700px;
      max-height: calc(100vh - 80px);
      overflow: hidden;
    }

    .phone-notch {
      width: 80px;
      height: 6px;
      border-radius: 999px;
      background: #e5e7eb;
      margin-bottom: 12px;
      flex-shrink: 0;
    }

    .phone-inner {
      width: 100%;
      border-radius: 26px;
      border: 1px solid rgba(148, 163, 184, 0.35);
      background: #0ea5e9; /* overridden via JS with chosen background */
      padding: 12px 10px 10px;
      display: flex;
      flex-direction: column;
      align-items: center;
      flex: 1;
      overflow: hidden;
      position: relative;
    }

    .shell-inner {
      width: 100%;
      max-width: 320px;
      margin: 0 auto;
      display: flex;
      flex-direction: column;
      align-items: stretch;
      height: 100%;
      position: relative;
      z-index: 1;
    }

    /* Logo */
    .top-row {
      display: flex;
      align-items: center;
      justify-content: center;
      margin-bottom: 4px;
      flex-shrink: 0;
    }

    .logo-group {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 4px;
    }

    .logo-mark {
      font-family: "Poppins", system-ui, sans-serif;
      font-size: 12px;
      font-weight: 700;
      letter-spacing: 0.20em;
      text-transform: uppercase;
      color: var(--text-main);
    }

    .logo-accent {
      width: 80px;
      height: 3px;
      border-radius: 999px;
      background: linear-gradient(90deg, #ff4f96, #ff7a4e, #22d3ee);
    }

    /* Very small header chip */
    .header-card {
      margin-bottom: 4px;
      padding: 5px 12px;
      border-radius: 999px;
      background: var(--frosted-bg);
      border: 1px solid var(--frosted-border);
      backdrop-filter: blur(10px);
      box-shadow: var(--frosted-shadow);
      text-align: center;
      align-self: center;
      flex-shrink: 0;
      transition: opacity 0.25s ease, transform 0.25s ease;
    }

    .header-card.header-hidden {
      opacity: 0;
      transform: translateY(-6px);
      pointer-events: none;
    }

    .header-title {
      font-family: "Poppins", system-ui, sans-serif;
      font-size: 11px;
      font-weight: 600;
      letter-spacing: 0.16em;
      text-transform: uppercase;
      color: var(--text-main);
      margin: 0;
    }

    /* Play area */
    .play-area {
      flex: 1;
      min-height: 0;
      margin: 4px 0 10px;
      position: relative;
    }

    #stickerCanvas {
      position: relative;
      width: 100%;
      height: 100%;
      touch-action: none;
    }

    .sticker {
      position: absolute;
      touch-action: none;
      user-select: none;
      transform-origin: center center;
      cursor: grab;
      border-radius: 18px;
    }

    .sticker img {
      width: 100%;
      height: 100%;
      object-fit: contain;
      pointer-events: none;
      user-select: none;
      display: block;
    }

    .sticker.active {
      box-shadow:
        0 0 0 2px rgba(14, 165, 233, 0.7),
        0 8px 18px rgba(15, 23, 42, 0.45);
    }

    /* Footer buttons */
    .footer-row {
      display: flex;
      align-items: center;
      gap: 10px;
      flex-shrink: 0;
    }

    .btn-outline {
      border-radius: 999px;
      border: 1px solid rgba(248, 250, 252, 0.85);
      padding: 8px 14px;
      font-size: 11px;
      font-weight: 600;
      cursor: pointer;
      background: rgba(15, 23, 42, 0.14);
      color: #f9fafb;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      white-space: nowrap;
      transition:
        transform 0.12s ease,
        box-shadow 0.18s ease,
        opacity 0.18s ease,
        background 0.18s ease;
      flex: 0 0 auto;
    }

    .btn-outline.hidden-remove {
      opacity: 0;
      pointer-events: none;
      transform: translateY(4px);
      box-shadow: none;
    }

    .btn-outline:not(.hidden-remove):active {
      transform: translateY(1px) scale(0.99);
      box-shadow: 0 4px 10px rgba(15, 23, 42, 0.55);
    }

    .btn-primary {
      border-radius: 999px;
      border: none;
      padding: 9px 20px;
      font-size: 11px;
      font-weight: 700;
      cursor: pointer;
      background: var(--button-gradient);
      color: var(--button-text);
      box-shadow:
        0 12px 22px rgba(236, 72, 153, 0.35),
        0 0 0 1px rgba(248, 250, 252, 0.5);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      letter-spacing: 0.16em;
      text-transform: uppercase;
      white-space: nowrap;
      transition:
        background 0.18s ease,
        transform 0.15s ease,
        box-shadow 0.18s ease,
        opacity 0.18s ease;
      flex: 1;
    }

    .btn-primary:not(:disabled):active {
      transform: translateY(1px) scale(0.99);
      box-shadow:
        0 6px 12px rgba(236, 72, 153, 0.30);
    }

    .btn-primary:disabled {
      opacity: 0.35;
      cursor: not-allowed;
      box-shadow:
        0 0 0 1px rgba(209, 213, 219, 0.8);
      background: linear-gradient(135deg, #f9fafb, #e5e7eb);
      color: #9ca3af;
    }

    /* Save toast */
    .save-toast {
      position: absolute;
      bottom: 14px;
      left: 50%;
      transform: translateX(-50%);
      padding: 6px 12px;
      border-radius: 999px;
      background: rgba(15, 23, 42, 0.9);
      color: #f9fafb;
      font-size: 10px;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.18s ease;
      z-index: 3;
    }

    .save-toast.visible {
      opacity: 1;
    }

    @media (max-width: 480px) {
      .phone-frame {
        height: 640px;
        max-height: calc(100vh - 48px);
        padding: 20px 14px 20px;
      }

      .phone-inner {
        padding: 10px 8px 10px;
      }

      .header-title {
        font-size: 10px;
      }

      .btn-primary {
        font-size: 10px;
      }
    }
  </style>
</head>
<body>
  <div class="app-shell">
    <div class="phone-frame">
      <div class="phone-notch"></div>

      <div class="phone-inner" id="phone-inner">
        <div class="shell-inner">
          <!-- Logo -->
          <div class="top-row">
            <div class="logo-group">
              <div class="logo-mark">STICKERBOOK</div>
              <div class="logo-accent"></div>
            </div>
          </div>

          <!-- Tiny header chip -->
          <div class="header-card" id="header-card">
            <h1 class="header-title">Arrange your stickers</h1>
          </div>

          <!-- Central play area -->
          <div class="play-area" id="play-area">
            <div id="stickerCanvas"></div>
          </div>

          <!-- Footer actions -->
          <div class="footer-row">
            <button id="remove-button" class="btn-outline hidden-remove" type="button" disabled>
              Remove sticker
            </button>
            <button id="continue-button" class="btn-primary" type="button">
              Continue
            </button>
          </div>
        </div>

        <div id="save-toast" class="save-toast">Page saved</div>
      </div>
    </div>
  </div>

  <script>
    const GRID_COLS = 4;
    const GRID_ROWS = 5;
    const SAFE_MARGIN = 8;

    const MIN_SCALE = 0.5; // 50% of start size
    const MAX_SCALE = 5;   // big collage mode

    const phoneInner = document.getElementById("phone-inner");
    const playArea = document.getElementById("play-area");
    const canvas = document.getElementById("stickerCanvas");
    const removeButton = document.getElementById("remove-button");
    const continueButton = document.getElementById("continue-button");
    const saveToast = document.getElementById("save-toast");
    const headerCard = document.getElementById("header-card");

    const isTouchDevice =
      "ontouchstart" in window || navigator.maxTouchPoints > 0;

    let pageData = null;
    let stickersData = [];
    let currentZ = 10;
    let activeSticker = null;
    let canvasBounds = { width: 0, height: 0 };
    let headerHidden = false;

    function hideHeaderCard() {
      if (headerHidden || !headerCard) return;
      headerHidden = true;
      headerCard.classList.add("header-hidden");
    }

    function showToast() {
      saveToast.classList.add("visible");
      setTimeout(() => {
        saveToast.classList.remove("visible");
      }, 1500);
    }

    function loadPageFromStorage() {
      const rawPage = localStorage.getItem("stickerbook_page_1");
      if (rawPage) {
        try {
          pageData = JSON.parse(rawPage);
        } catch {
          pageData = null;
        }
      }

      if (!pageData || !pageData.stickers || !Array.isArray(pageData.stickers)) {
        const bg =
          localStorage.getItem("stickerbook_page_1_background") ||
          localStorage.getItem("current_page_background") ||
          "#ffffff";

        let stickerIds = [];
        try {
          const rawSel = localStorage.getItem("stickerbookSelectedStickers");
          if (rawSel) {
            const arr = JSON.parse(rawSel);
            if (Array.isArray(arr)) stickerIds = arr;
          }
        } catch {
          stickerIds = [];
        }

        pageData = {
          background: bg,
          stickers: stickerIds.map((id) => ({ id, src: null }))
        };
      }

      // Hydrate src from stickerbook_pages if needed
      try {
        const allPagesRaw = localStorage.getItem("stickerbook_pages");
        if (allPagesRaw) {
          const allPages = JSON.parse(allPagesRaw);
          if (allPages && allPages.page_1 && Array.isArray(allPages.page_1.stickers)) {
            const map = {};
            allPages.page_1.stickers.forEach((s) => {
              map[s.id] = s.src || s.image;
            });
            pageData.stickers.forEach((s) => {
              if (!s.src && map[s.id]) {
                s.src = map[s.id];
              }
            });
          }
        }
      } catch {
        // ignore
      }

      pageData.stickers = pageData.stickers.filter((s) => !!s.src);
    }

    function updateBackground() {
      const bg = pageData && pageData.background ? pageData.background : "#ffffff";
      phoneInner.style.background = bg;
    }

    function recalcCanvasBounds() {
      const rect = playArea.getBoundingClientRect();
      canvasBounds.width = rect.width;
      canvasBounds.height = rect.height;
    }

    function layoutStickersOnGrid() {
      if (!pageData || !pageData.stickers) return;

      recalcCanvasBounds();

      const innerWidth = canvasBounds.width - SAFE_MARGIN * 2;
      const innerHeight = canvasBounds.height - SAFE_MARGIN * 2;
      const cellWidth = innerWidth / GRID_COLS;
      const cellHeight = innerHeight / GRID_ROWS;

      const maxCells = GRID_COLS * GRID_ROWS;
      const count = Math.min(pageData.stickers.length, maxCells);

      for (let index = 0; index < count; index++) {
        const sticker = pageData.stickers[index];
        const row = Math.floor(index / GRID_COLS);
        const col = index % GRID_COLS;

        const cellCenterX = SAFE_MARGIN + col * cellWidth + cellWidth / 2;
        const cellCenterY = SAFE_MARGIN + row * cellHeight + cellHeight / 2;

        // BIGGER starting stickers
        const stickerSize = Math.min(cellWidth, cellHeight) * 0.95;

        sticker.scale = 1;
        sticker.rotation = 0;
        sticker.size = stickerSize;

        const halfSize = stickerSize / 2;
        sticker.x = cellCenterX - halfSize;
        sticker.y = cellCenterY - halfSize;
      }

      // extra stickers (if any) stack at bottom center
      for (let i = maxCells; i < pageData.stickers.length; i++) {
        const sticker = pageData.stickers[i];
        const stickerSize = Math.min(cellWidth, cellHeight) * 0.95;
        sticker.scale = 1;
        sticker.rotation = 0;
        sticker.size = stickerSize;
        const halfSize = stickerSize / 2;
        sticker.x = canvasBounds.width / 2 - halfSize;
        sticker.y = canvasBounds.height - SAFE_MARGIN - stickerSize;
      }

      stickersData = pageData.stickers;
    }

    // Constrain sticker so it stays in the vertical "safe" area under the logo/pill.
    // We still allow some side "fall off", but top can't creep up over the header.
    function clampStickerPosition(stickerObj) {
      const size = stickerObj.size || 80;
      const scale = stickerObj.scale || 1;
      const scaledSize = size * scale;
      const extra = (scaledSize - size) / 2; // how much the transform extends past the box on each side

      // Horizontal: keep like before (you still get some side bleed visually)
      const minX = SAFE_MARGIN;
      const maxX = canvasBounds.width - size - SAFE_MARGIN;

      // Vertical: account for the scaled visual height so it can't cover the header area
      const minY = SAFE_MARGIN + extra; // push down as it grows
      const maxY = canvasBounds.height - SAFE_MARGIN - size - extra;

      if (stickerObj.x < minX) stickerObj.x = minX;
      if (stickerObj.x > maxX) stickerObj.x = maxX;

      // If scaled so huge that minY > maxY, clamp to center-ish
      if (minY > maxY) {
        const mid = (canvasBounds.height - size) / 2;
        stickerObj.y = mid;
      } else {
        if (stickerObj.y < minY) stickerObj.y = minY;
        if (stickerObj.y > maxY) stickerObj.y = maxY;
      }
    }

    function setActiveSticker(el) {
      if (activeSticker === el) return;

      // Hide header as soon as user interacts with a sticker
      hideHeaderCard();

      if (activeSticker) {
        activeSticker.classList.remove("active");
      }
      activeSticker = el;

      if (activeSticker) {
        activeSticker.classList.add("active");
        removeButton.disabled = false;
        removeButton.classList.remove("hidden-remove");
      } else {
        removeButton.disabled = true;
        removeButton.classList.add("hidden-remove");
      }
    }

    function saveLayoutToStorage() {
      const els = Array.from(canvas.querySelectorAll(".sticker"));
      const stickers = els.map((el) => ({
        id: el.dataset.id,
        src: el.dataset.src,
        x: parseFloat(el.dataset.x) || 0,
        y: parseFloat(el.dataset.y) || 0,
        scale: parseFloat(el.dataset.scale) || 1,
        rotation: parseFloat(el.dataset.rotation) || 0,
        zIndex: parseInt(el.style.zIndex || "1", 10)
      }));

      const bg =
        (pageData && pageData.background) ||
        phoneInner.style.background ||
        "#ffffff";

      const page1 = {
        background: bg,
        stickers
      };

      localStorage.setItem("stickerbook_page_1", JSON.stringify(page1));

      try {
        const existingRaw = localStorage.getItem("stickerbook_pages");
        const existing = existingRaw ? JSON.parse(existingRaw) : {};
        existing.page_1 = page1;
        localStorage.setItem("stickerbook_pages", JSON.stringify(existing));
      } catch {
        localStorage.setItem("stickerbook_pages", JSON.stringify({ page_1: page1 }));
      }
    }

    function handleRemoveActiveSticker() {
      if (!activeSticker) return;

      const id = activeSticker.dataset.id;
      stickersData = stickersData.filter((s) => s.id !== id);

      activeSticker.remove();
      setActiveSticker(null);
      saveLayoutToStorage();
    }

    function createStickerElement(stickerObj) {
      const el = document.createElement("div");
      el.className = "sticker";

      const size = stickerObj.size || 80;
      clampStickerPosition(stickerObj);

      el.style.width = size + "px";
      el.style.height = size + "px";
      el.style.left = stickerObj.x + "px";
      el.style.top = stickerObj.y + "px";

      const scale = stickerObj.scale || 1;
      const rotation = stickerObj.rotation || 0;

      el.style.transform = `scale(${scale}) rotate(${rotation}deg)`;
      el.style.zIndex = (stickerObj.zIndex && Number.isFinite(stickerObj.zIndex))
        ? stickerObj.zIndex
        : ++currentZ;

      el.dataset.id = stickerObj.id;
      el.dataset.src = stickerObj.src;
      el.dataset.x = stickerObj.x;
      el.dataset.y = stickerObj.y;
      el.dataset.scale = scale;
      el.dataset.rotation = rotation;

      const img = document.createElement("img");
      img.src = stickerObj.src;
      img.alt = "";
      el.appendChild(img);

      // tap/click to select
      el.addEventListener("click", (event) => {
        event.stopPropagation();
        setActiveSticker(el);
        el.style.zIndex = ++currentZ;
      });

      setupDesktopDrag(el);
      setupTouchGestures(el);

      return el;
    }

    function setupDesktopDrag(el) {
      if (isTouchDevice) return; // mobile uses touch handlers

      el.addEventListener("mousedown", (e) => {
        e.preventDefault();
        e.stopPropagation();

        setActiveSticker(el);
        el.style.zIndex = ++currentZ;

        const id = el.dataset.id;
        const st = stickersData.find((s) => s.id === id);
        if (!st) return;

        const startX = st.x;
        const startY = st.y;
        const startMouseX = e.clientX;
        const startMouseY = e.clientY;

        function onMove(ev) {
          const dx = ev.clientX - startMouseX;
          const dy = ev.clientY - startMouseY;

          st.x = startX + dx;
          st.y = startY + dy;

          clampStickerPosition(st);

          el.dataset.x = st.x;
          el.dataset.y = st.y;
          el.style.left = st.x + "px";
          el.style.top = st.y + "px";
        }

        function onUp() {
          window.removeEventListener("mousemove", onMove);
          window.removeEventListener("mouseup", onUp);
          saveLayoutToStorage();
        }

        window.addEventListener("mousemove", onMove);
        window.addEventListener("mouseup", onUp);
      });
    }

    function setupTouchGestures(el) {
      if (!isTouchDevice) return;

      let touchMode = null; // "pan" or "transform"
      let startX = 0;
      let startY = 0;
      let startTouchX = 0;
      let startTouchY = 0;

      let initialDistance = 0;
      let initialAngle = 0;
      let startScale = 1;
      let startRotation = 0;

      const getStickerState = () => {
        const id = el.dataset.id;
        return stickersData.find((s) => s.id === id);
      };

      el.addEventListener("touchstart", (e) => {
        if (e.touches.length === 0) return;
        setActiveSticker(el);
        el.style.zIndex = ++currentZ;

        const st = getStickerState();
        if (!st) return;

        if (e.touches.length === 1) {
          // drag
          touchMode = "pan";
          const t = e.touches[0];
          startX = st.x;
          startY = st.y;
          startTouchX = t.clientX;
          startTouchY = t.clientY;
        } else if (e.touches.length === 2) {
          // pinch/rotate
          touchMode = "transform";
          const t1 = e.touches[0];
          const t2 = e.touches[1];
          const dx = t2.clientX - t1.clientX;
          const dy = t2.clientY - t1.clientY;
          initialDistance = Math.hypot(dx, dy) || 1;
          initialAngle = Math.atan2(dy, dx);

          startScale = st.scale || parseFloat(el.dataset.scale) || 1;
          startRotation = st.rotation || parseFloat(el.dataset.rotation) || 0;
        }
      }, { passive: false });

      el.addEventListener("touchmove", (e) => {
        if (!touchMode) return;
        const st = getStickerState();
        if (!st) return;

        e.preventDefault();

        if (touchMode === "pan" && e.touches.length === 1) {
          const t = e.touches[0];
          const dx = t.clientX - startTouchX;
          const dy = t.clientY - startTouchY;

          st.x = startX + dx;
          st.y = startY + dy;

          clampStickerPosition(st);

          el.dataset.x = st.x;
          el.dataset.y = st.y;
          el.style.left = st.x + "px";
          el.style.top = st.y + "px";
        } else if (touchMode === "transform" && e.touches.length >= 2) {
          const t1 = e.touches[0];
          const t2 = e.touches[1];
          const dx = t2.clientX - t1.clientX;
          const dy = t2.clientY - t1.clientY;

          const distance = Math.hypot(dx, dy);
          const angle = Math.atan2(dy, dx);

          const scaleFactor = distance / (initialDistance || distance);
          let newScale = startScale * scaleFactor;

          if (newScale < MIN_SCALE) newScale = MIN_SCALE;
          if (newScale > MAX_SCALE) newScale = MAX_SCALE;

          const rotationDelta = angle - initialAngle;
          const newRotation = startRotation + (rotationDelta * 180 / Math.PI);

          st.scale = newScale;
          st.rotation = newRotation;

          // Re-clamp vertically based on new scale so it doesn't cover header
          clampStickerPosition(st);

          el.dataset.x = st.x;
          el.dataset.y = st.y;
          el.dataset.scale = newScale;
          el.dataset.rotation = newRotation;
          el.style.left = st.x + "px";
          el.style.top = st.y + "px";
          el.style.transform = `scale(${newScale}) rotate(${newRotation}deg)`;
        }
      }, { passive: false });

      const handleTouchEndOrCancel = (e) => {
        const st = getStickerState();
        if (!st) {
          touchMode = null;
          return;
        }

        if (e.touches.length === 0) {
          // gesture fully ended
          touchMode = null;
          saveLayoutToStorage();
        } else if (touchMode === "transform" && e.touches.length === 1) {
          // dropped back to one finger: switch to pan
          const t = e.touches[0];
          startX = st.x;
          startY = st.y;
          startTouchX = t.clientX;
          startTouchY = t.clientY;
          touchMode = "pan";
        }
      };

      el.addEventListener("touchend", handleTouchEndOrCancel, { passive: false });
      el.addEventListener("touchcancel", handleTouchEndOrCancel, { passive: false });
    }

    function renderStickers() {
      canvas.innerHTML = "";
      stickersData.forEach((sticker) => {
        const el = createStickerElement(sticker);
        canvas.appendChild(el);
      });
      setActiveSticker(null);
    }

    function init() {
      loadPageFromStorage();
      updateBackground();
      recalcCanvasBounds();
      layoutStickersOnGrid();
      renderStickers();

      // Auto fade the pill after 5 seconds as a backup
      setTimeout(hideHeaderCard, 5000);

      removeButton.addEventListener("click", (event) => {
        event.stopPropagation();
        handleRemoveActiveSticker();
      });

      continueButton.addEventListener("click", () => {
        saveLayoutToStorage();
        showToast();
      });

      playArea.addEventListener("click", (event) => {
        if (event.target === playArea || event.target === canvas) {
          setActiveSticker(null);
        }
      });

      window.addEventListener("resize", () => {
        recalcCanvasBounds();
        // don't re-grid on resize; keep user layout
      });
    }

    document.addEventListener("DOMContentLoaded", init);
  </script>
</body>
</html>
